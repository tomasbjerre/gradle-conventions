import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.Property
import org.gradle.api.provider.ListProperty

class ReleaseExtension {
	final Property<String> ignoreCommitsIfMessageMatches
	/**
	 * If not prepending, it will rewrite the entire changelog
	 */
	final Property<Boolean> prependChangelogToFile
	final Property<Boolean> updateChangelog
	final Property<String> mavenRepositoryUrl
	final Property<String> nexusUsernameEnvOrProp
	final Property<String> nexusPasswordEnvOrProp
	final Property<String> nexusStagingProfileEnvOrProp
	final ListProperty<String> releasePostTasks

	ReleaseExtension(ObjectFactory objects) {
		ignoreCommitsIfMessageMatches = objects.property(String)
		prependChangelogToFile = objects.property(Boolean)
		updateChangelog = objects.property(Boolean)
		mavenRepositoryUrl = objects.property(String)
		nexusUsernameEnvOrProp = objects.property(String)
		nexusPasswordEnvOrProp = objects.property(String)
		nexusStagingProfileEnvOrProp = objects.property(String)
		releasePostTasks = objects.listProperty(String)

		// Set defaults
		ignoreCommitsIfMessageMatches.convention("^\\[maven-release-plugin\\].*|^\\[Gradle Release Plugin\\].*|^Merge.*|.*\\[GRADLE SCRIPT\\].*")
		prependChangelogToFile.convention(true)
		updateChangelog.convention(true)
		mavenRepositoryUrl.convention("https://ossrh-staging-api.central.sonatype.com/service/local/")
		nexusUsernameEnvOrProp.convention("nexusUsername")
		nexusPasswordEnvOrProp.convention("nexusPassword")
		nexusStagingProfileEnvOrProp.convention("se.bjurr")
	}
}

project.extensions.create('releaseExtension', ReleaseExtension, project.objects)
project.plugins.apply "io.github.gradle-nexus.publish-plugin"
project.plugins.apply "se.bjurr.gitchangelog.git-changelog-gradle-plugin"

gitChangelogSemanticVersion {
	suffixSnapshotIfNotTagged.set(false)
	patchVersionPattern.set("[Ff]ix|[Cc]hore\\(deps\\)")
}

gitChangelog {
	ignoreCommitsIfMessageMatches = project.extensions.releaseExtension.ignoreCommitsIfMessageMatches
	prependToFile = project.extensions.releaseExtension.prependChangelogToFile
}

plugins.withId("io.github.gradle-nexus.publish-plugin") {
	nexusPublishing {
		repositories {
			sonatype {
				nexusUrl.set(project.provider { uri(project.extensions.releaseExtension.mavenRepositoryUrl) })
				username.set(project.providers
						.environmentVariable(project.extensions.releaseExtension.nexusUsernameEnvOrProp)
						.orElse(project.provider { project.findProperty(project.extensions.releaseExtension.nexusUsernameEnvOrProp.get()) })
						)
				password.set(project.providers
						.environmentVariable(project.extensions.releaseExtension.nexusPasswordEnvOrProp)
						.orElse(project.provider { project.findProperty(project.extensions.releaseExtension.nexusPasswordEnvOrProp.get()) })
						)
				stagingProfileId.set(project.providers
						.environmentVariable(project.extensions.releaseExtension.nexusStagingProfileEnvOrProp)
						.orElse(project.provider { project.findProperty(project.extensions.releaseExtension.nexusStagingProfileEnvOrProp.get()) })
						)
			}
		}
	}
}

/**
 * Release process
 */
tasks.register('updateVersion', GradleBuild) {
	tasks = [
		'gitChangelogSemanticVersion',
		'commitNewVersionTask',
	]
}

tasks.register('release', GradleBuild) {
	tasks = ['clean']

	doFirst {
		tasks += ['publishToMavenLocal']

		if (project.extensions.releaseExtension.updateChangelog.get()) {
			tasks += [
				'gitChangelog',
				'commitChangelogTask'
			]
		}

		tasks += project.extensions.releaseExtension.releasePostTasks.get()
	}
}

/**
 * Supporting methods
 */
def shouldGitIgnore(filename) {
	if (!file('.gitignore').text.contains(filename)) {
		throw new RuntimeException("The .gitignore should include '${filename}'")
	}
	logger.lifecycle("${filename} is ignored")
}


tasks.register('commitNewVersionTask') {
	doLast {
		def commitResult = new ProcessBuilder('git', 'commit', '-a', '-m', "chore(release): ${project.version} [GRADLE SCRIPT]")
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		def pushResult = new ProcessBuilder('git', 'push')
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		logger.lifecycle("Git commit exit code: ${commitResult}, push exit code: ${pushResult}")

		def tagResult = new ProcessBuilder('git', 'tag', "${project.version}")
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		def pushTagResult = new ProcessBuilder('git', 'push', 'origin', "${project.version}")
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		def pushAllTagsResult = new ProcessBuilder('git', 'push', '--tags')
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		logger.lifecycle("Git tag exit code: ${tagResult}, push tag exit code: ${pushTagResult}, push all tags exit code: ${pushAllTagsResult}")
	}
}

tasks.register('commitChangelogTask') {
	doLast {
		int commitResult = new ProcessBuilder('git', 'commit', '-a', '-m', "chore(release): Updating changelog with ${project.version} [GRADLE SCRIPT]")
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		def pushResult = new ProcessBuilder('git', 'push')
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		logger.lifecycle("Git commit exit code: ${commitResult}, push exit code: ${pushResult}")
	}
}