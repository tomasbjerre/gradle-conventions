import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.Property
import org.gradle.api.provider.ListProperty

class ReleaseExtension {
	final Property<String> ignoreCommitsIfMessageMatches
	/**
	 * If not prepending, it will rewrite the entire changelog
	 */
	final Property<Boolean> prependChangelogToFile
	final Property<Boolean> updateChangelog
	final ListProperty<String> releasePostTasks

	ReleaseExtension(ObjectFactory objects) {
		ignoreCommitsIfMessageMatches = objects.property(String)
		prependChangelogToFile = objects.property(Boolean)
		updateChangelog = objects.property(Boolean)
		releasePostTasks = objects.listProperty(String)

		// Set defaults
		ignoreCommitsIfMessageMatches.convention("^\\[maven-release-plugin\\].*|^\\[Gradle Release Plugin\\].*|^Merge.*|.*\\[GRADLE SCRIPT\\].*")
		prependChangelogToFile.convention(true)
		updateChangelog.convention(true)
	}
}

project.extensions.create('releaseExtension', ReleaseExtension, project.objects)
project.plugins.apply "se.bjurr.gitchangelog.git-changelog-gradle-plugin"

gitChangelogSemanticVersion {
	suffixSnapshotIfNotTagged.set(false)
	patchVersionPattern.set("[Ff]ix|[Cc]hore\\(deps\\)")
}

gitChangelog {
	ignoreCommitsIfMessageMatches = project.extensions.releaseExtension.ignoreCommitsIfMessageMatches
	prependToFile = project.extensions.releaseExtension.prependChangelogToFile
}

allprojects {
	project.plugins.apply 'com.vanniktech.maven.publish.base'

	mavenPublishing {
		publishToMavenCentral()
	}
}

/**
 * Release process
 */
tasks.register('updateVersion', GradleBuild) {
	tasks = [
		'gitChangelogSemanticVersion',
		'commitNewVersionTask',
	]
}

tasks.register('release', GradleBuild) {
	tasks = ['clean']

	doFirst {
		tasks += ['publishToMavenLocal']

		if (project.extensions.releaseExtension.updateChangelog.get()) {
			tasks += [
				'gitChangelog',
				'commitChangelogTask'
			]
		}

		tasks += project.extensions.releaseExtension.releasePostTasks.get()
		logger.lifecycle("Releasing with tasks: ${tasks}")
	}
}

/**
 * Supporting methods
 */
def shouldGitIgnore(filename) {
	if (!file('.gitignore').text.contains(filename)) {
		throw new RuntimeException("The .gitignore should include '${filename}'")
	}
	logger.lifecycle("${filename} is ignored")
}


tasks.register('commitNewVersionTask') {
	doLast {
		def commitResult = new ProcessBuilder('git', 'commit', '-a', '-m', "chore(release): ${project.version} [GRADLE SCRIPT]")
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		def pushResult = new ProcessBuilder('git', 'push')
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		logger.lifecycle("Git commit exit code: ${commitResult}, push exit code: ${pushResult}")

		def tagResult = new ProcessBuilder('git', 'tag', "${project.version}")
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		def pushTagResult = new ProcessBuilder('git', 'push', 'origin', "${project.version}")
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		def pushAllTagsResult = new ProcessBuilder('git', 'push', '--tags')
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		logger.lifecycle("Git tag exit code: ${tagResult}, push tag exit code: ${pushTagResult}, push all tags exit code: ${pushAllTagsResult}")
	}
}

tasks.register('commitChangelogTask') {
	doLast {
		int commitResult = new ProcessBuilder('git', 'commit', '-a', '-m', "chore(release): Updating changelog with ${project.version} [GRADLE SCRIPT]")
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		def pushResult = new ProcessBuilder('git', 'push')
				.directory(project.projectDir)
				.inheritIO()
				.start()
				.waitFor()

		logger.lifecycle("Git commit exit code: ${commitResult}, push exit code: ${pushResult}")
	}
}